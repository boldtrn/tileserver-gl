<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>{{name}} - TileServer GL</title>
  <link rel="stylesheet" type="text/css" href="{{public_url}}maplibre-gl.css{{&key_query}}" />
  <link rel="stylesheet" type="text/css" href="{{public_url}}maplibre-gl-inspect.css{{&key_query}}" />
  <link rel="stylesheet" type="text/css" href="{{public_url}}leaflet.css{{&key_query}}" />
  <script src="{{public_url}}maplibre-gl.js{{&key_query}}"></script>
  <script src="{{public_url}}maplibre-gl-inspect.min.js{{&key_query}}"></script>
  <script src="{{public_url}}leaflet.js{{&key_query}}"></script>
  <script src="{{public_url}}leaflet-hash.js{{&key_query}}"></script>
  <style>
    body { margin:0; padding:0; }
    #map { position:absolute; top:0; bottom:0; width:100%; }
  </style>
</head>
<body>
  <h1 style="display:none;">{{name}}</h1>
  <div id='map'></div>
  <script>
    var q = (location.search || '').substr(1).split('&');
    var preference =
      q.indexOf('vector') >= 0 ? 'vector' :
        (q.indexOf('raster') >= 0 ? 'raster' :
          (maplibregl.supported() ? 'vector' : 'raster'));
    if (preference == 'vector') {
      maplibregl.setRTLTextPlugin('{{public_url}}mapbox-gl-rtl-text.js{{&key_query}}');
      var map = new maplibregl.Map({
        container: 'map',
        style: '{{public_url}}styles/{{id}}/style.json{{&key_query}}',
        hash: true
      });
      map.addControl(new maplibregl.NavigationControl({
         visualizePitch: true,
         showZoom: true,
         showCompass: true
      }));
      map.addControl(new MaplibreInspect({
         showMapPopupOnHover: false,
         showInspectMapPopupOnHover: false,
         selectThreshold: 5
      }));
    } else {
	
		function findValueOfProperty(obj, propertyName){
			let reg = new RegExp(propertyName, "i"); // "i" to make it case insensitive
			return Object.keys(obj).reduce((result, key) => {
				if( reg.test(key) ) result.push(obj[key]);
				return result;
			}, []);
		}

		function decodeHTMLEntities(text) {
		  var textArea = document.createElement('textarea');
		  textArea.innerHTML = text;
		  return textArea.value;
		}

		var map = L.map('map', { zoomControl: false });
		new L.Control.Zoom({ position: 'topright' }).addTo(map);
		
		var tile_url, tile_attribution, tile_minzoom, tile_maxzoom;
		fetch('{{public_url}}styles/{{id}}.json{{&key_query}}')
		  .then(
			response => {
			  if (response.status !== 200) {
				console.log('There was an issue fetching the style json. Status Code: ' +
				  response.status);
				return;
			  }

			  response.json().then(function(data) {
				// Get TileJSON url, Attribution, and Min/Max Zoom from style json file
				for (const [key, value] of Object.entries(data)) {
					var keyl = key.toLowerCase();
					switch(keyl) {
					  case "tiles":
						tile_url = value[0];
						break;
					  case "attribution":
						tile_attribution = decodeHTMLEntities(value);
						break;
					  case "minzoom":
						tile_minzoom = value;
						break;
					  case "maxzoom":
						tile_maxzoom = value;
						break;
					}
					console.log(`${keyl}: ${value}`);
				}
				
				// Format Attributions. remove any entries that are whitespace. remove any entries that are substrings of another entry. first sort by length so that substrings come first
				var attributions = tile_attribution.split("; ");
				attributions = attributions.filter(e => String(e).trim());
				attributions.sort((a, b) => a.length - b.length);
				attributions = attributions.filter((attrib, i) => {
					for (let j = i + 1; j < attributions.length; j++) {
						if (attributions[j].indexOf(attrib) >= 0) { return false; }
					}
					return true;
				});
				attribHTML = attributions.join(' | ');

				// Load TilJSON layer.
				L.tileLayer(tile_url, {
					minZoom: tile_minzoom,
					maxZoom: tile_maxzoom,
					attribution: attribHTML
				}).addTo(map);
				
				map.eachLayer(function(layer) {
				  // do not add scale prefix even if retina display is detected
				  layer.scalePrefix = '.';
				});
			  });
			})
		  .catch(err => console.log('Could not fetch style json', err));
      
		setTimeout(function() {
			new L.Hash(map);
		}, 0);
    }
  </script>
</body>
</html>
